// @generated by protoc-gen-es v1.6.0 with parameter "target=ts"
// @generated from file mystiko/api/config/v1/response.proto (package mystiko.api.config.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type {
  BinaryReadOptions,
  FieldList,
  JsonReadOptions,
  JsonValue,
  PartialMessage,
  PlainMessage,
} from '@bufbuild/protobuf';
import { Message, proto3 } from '@bufbuild/protobuf';
import { MystikoConfig } from '../../../config/v1/mystiko_pb.js';
import { CircuitConfig } from '../../../config/v1/circuit_pb.js';
import { ChainConfig } from '../../../config/v1/chain_pb.js';
import { BridgeType } from '../../../common/v1/types_pb.js';
import { BridgeConfig } from '../../../config/bridge/v1/bridge_pb.js';
import { DepositContractConfig } from '../../../config/contract/v1/deposit_pb.js';
import { PoolContractConfig } from '../../../config/contract/v1/pool_pb.js';
import { ContractConfig } from '../../../config/contract/v1/contract_pb.js';

/**
 * @generated from message mystiko.api.config.v1.GetConfigResponse
 */
export class GetConfigResponse extends Message<GetConfigResponse> {
  /**
   * @generated from field: mystiko.config.v1.MystikoConfig config = 1;
   */
  config?: MystikoConfig;

  constructor(data?: PartialMessage<GetConfigResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'mystiko.api.config.v1.GetConfigResponse';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'config', kind: 'message', T: MystikoConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConfigResponse {
    return new GetConfigResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConfigResponse {
    return new GetConfigResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConfigResponse {
    return new GetConfigResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: GetConfigResponse | PlainMessage<GetConfigResponse> | undefined,
    b: GetConfigResponse | PlainMessage<GetConfigResponse> | undefined,
  ): boolean {
    return proto3.util.equals(GetConfigResponse, a, b);
  }
}

/**
 * @generated from message mystiko.api.config.v1.FindDefaultCircuitResponse
 */
export class FindDefaultCircuitResponse extends Message<FindDefaultCircuitResponse> {
  /**
   * @generated from field: optional mystiko.config.v1.CircuitConfig config = 1;
   */
  config?: CircuitConfig;

  constructor(data?: PartialMessage<FindDefaultCircuitResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'mystiko.api.config.v1.FindDefaultCircuitResponse';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'config', kind: 'message', T: CircuitConfig, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FindDefaultCircuitResponse {
    return new FindDefaultCircuitResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FindDefaultCircuitResponse {
    return new FindDefaultCircuitResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FindDefaultCircuitResponse {
    return new FindDefaultCircuitResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: FindDefaultCircuitResponse | PlainMessage<FindDefaultCircuitResponse> | undefined,
    b: FindDefaultCircuitResponse | PlainMessage<FindDefaultCircuitResponse> | undefined,
  ): boolean {
    return proto3.util.equals(FindDefaultCircuitResponse, a, b);
  }
}

/**
 * @generated from message mystiko.api.config.v1.FindCircuitResponse
 */
export class FindCircuitResponse extends Message<FindCircuitResponse> {
  /**
   * @generated from field: optional mystiko.config.v1.CircuitConfig config = 1;
   */
  config?: CircuitConfig;

  constructor(data?: PartialMessage<FindCircuitResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'mystiko.api.config.v1.FindCircuitResponse';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'config', kind: 'message', T: CircuitConfig, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FindCircuitResponse {
    return new FindCircuitResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FindCircuitResponse {
    return new FindCircuitResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FindCircuitResponse {
    return new FindCircuitResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: FindCircuitResponse | PlainMessage<FindCircuitResponse> | undefined,
    b: FindCircuitResponse | PlainMessage<FindCircuitResponse> | undefined,
  ): boolean {
    return proto3.util.equals(FindCircuitResponse, a, b);
  }
}

/**
 * @generated from message mystiko.api.config.v1.FindChainResponse
 */
export class FindChainResponse extends Message<FindChainResponse> {
  /**
   * @generated from field: optional mystiko.config.v1.ChainConfig config = 1;
   */
  config?: ChainConfig;

  constructor(data?: PartialMessage<FindChainResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'mystiko.api.config.v1.FindChainResponse';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'config', kind: 'message', T: ChainConfig, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FindChainResponse {
    return new FindChainResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FindChainResponse {
    return new FindChainResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FindChainResponse {
    return new FindChainResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: FindChainResponse | PlainMessage<FindChainResponse> | undefined,
    b: FindChainResponse | PlainMessage<FindChainResponse> | undefined,
  ): boolean {
    return proto3.util.equals(FindChainResponse, a, b);
  }
}

/**
 * @generated from message mystiko.api.config.v1.FindPeerChainsResponse
 */
export class FindPeerChainsResponse extends Message<FindPeerChainsResponse> {
  /**
   * @generated from field: repeated mystiko.config.v1.ChainConfig configs = 1;
   */
  configs: ChainConfig[] = [];

  constructor(data?: PartialMessage<FindPeerChainsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'mystiko.api.config.v1.FindPeerChainsResponse';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'configs', kind: 'message', T: ChainConfig, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FindPeerChainsResponse {
    return new FindPeerChainsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FindPeerChainsResponse {
    return new FindPeerChainsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FindPeerChainsResponse {
    return new FindPeerChainsResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: FindPeerChainsResponse | PlainMessage<FindPeerChainsResponse> | undefined,
    b: FindPeerChainsResponse | PlainMessage<FindPeerChainsResponse> | undefined,
  ): boolean {
    return proto3.util.equals(FindPeerChainsResponse, a, b);
  }
}

/**
 * @generated from message mystiko.api.config.v1.FindAssetSymbolsResponse
 */
export class FindAssetSymbolsResponse extends Message<FindAssetSymbolsResponse> {
  /**
   * @generated from field: repeated string asset_symbol = 1;
   */
  assetSymbol: string[] = [];

  constructor(data?: PartialMessage<FindAssetSymbolsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'mystiko.api.config.v1.FindAssetSymbolsResponse';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'asset_symbol', kind: 'scalar', T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FindAssetSymbolsResponse {
    return new FindAssetSymbolsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FindAssetSymbolsResponse {
    return new FindAssetSymbolsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FindAssetSymbolsResponse {
    return new FindAssetSymbolsResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: FindAssetSymbolsResponse | PlainMessage<FindAssetSymbolsResponse> | undefined,
    b: FindAssetSymbolsResponse | PlainMessage<FindAssetSymbolsResponse> | undefined,
  ): boolean {
    return proto3.util.equals(FindAssetSymbolsResponse, a, b);
  }
}

/**
 * @generated from message mystiko.api.config.v1.FindBridgesResponse
 */
export class FindBridgesResponse extends Message<FindBridgesResponse> {
  /**
   * @generated from field: repeated mystiko.common.v1.BridgeType bridge_type = 1;
   */
  bridgeType: BridgeType[] = [];

  constructor(data?: PartialMessage<FindBridgesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'mystiko.api.config.v1.FindBridgesResponse';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'bridge_type', kind: 'enum', T: proto3.getEnumType(BridgeType), repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FindBridgesResponse {
    return new FindBridgesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FindBridgesResponse {
    return new FindBridgesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FindBridgesResponse {
    return new FindBridgesResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: FindBridgesResponse | PlainMessage<FindBridgesResponse> | undefined,
    b: FindBridgesResponse | PlainMessage<FindBridgesResponse> | undefined,
  ): boolean {
    return proto3.util.equals(FindBridgesResponse, a, b);
  }
}

/**
 * @generated from message mystiko.api.config.v1.FindBridgeResponse
 */
export class FindBridgeResponse extends Message<FindBridgeResponse> {
  /**
   * @generated from field: optional mystiko.config.bridge.v1.BridgeConfig config = 1;
   */
  config?: BridgeConfig;

  constructor(data?: PartialMessage<FindBridgeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'mystiko.api.config.v1.FindBridgeResponse';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'config', kind: 'message', T: BridgeConfig, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FindBridgeResponse {
    return new FindBridgeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FindBridgeResponse {
    return new FindBridgeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FindBridgeResponse {
    return new FindBridgeResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: FindBridgeResponse | PlainMessage<FindBridgeResponse> | undefined,
    b: FindBridgeResponse | PlainMessage<FindBridgeResponse> | undefined,
  ): boolean {
    return proto3.util.equals(FindBridgeResponse, a, b);
  }
}

/**
 * @generated from message mystiko.api.config.v1.FindDepositContractResponse
 */
export class FindDepositContractResponse extends Message<FindDepositContractResponse> {
  /**
   * @generated from field: optional mystiko.config.contract.v1.DepositContractConfig config = 1;
   */
  config?: DepositContractConfig;

  constructor(data?: PartialMessage<FindDepositContractResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'mystiko.api.config.v1.FindDepositContractResponse';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'config', kind: 'message', T: DepositContractConfig, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FindDepositContractResponse {
    return new FindDepositContractResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FindDepositContractResponse {
    return new FindDepositContractResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FindDepositContractResponse {
    return new FindDepositContractResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: FindDepositContractResponse | PlainMessage<FindDepositContractResponse> | undefined,
    b: FindDepositContractResponse | PlainMessage<FindDepositContractResponse> | undefined,
  ): boolean {
    return proto3.util.equals(FindDepositContractResponse, a, b);
  }
}

/**
 * @generated from message mystiko.api.config.v1.FindDepositContractByAddressResponse
 */
export class FindDepositContractByAddressResponse extends Message<FindDepositContractByAddressResponse> {
  /**
   * @generated from field: optional mystiko.config.contract.v1.DepositContractConfig config = 1;
   */
  config?: DepositContractConfig;

  constructor(data?: PartialMessage<FindDepositContractByAddressResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'mystiko.api.config.v1.FindDepositContractByAddressResponse';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'config', kind: 'message', T: DepositContractConfig, opt: true },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): FindDepositContractByAddressResponse {
    return new FindDepositContractByAddressResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): FindDepositContractByAddressResponse {
    return new FindDepositContractByAddressResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): FindDepositContractByAddressResponse {
    return new FindDepositContractByAddressResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: FindDepositContractByAddressResponse | PlainMessage<FindDepositContractByAddressResponse> | undefined,
    b: FindDepositContractByAddressResponse | PlainMessage<FindDepositContractByAddressResponse> | undefined,
  ): boolean {
    return proto3.util.equals(FindDepositContractByAddressResponse, a, b);
  }
}

/**
 * @generated from message mystiko.api.config.v1.FindPoolContractResponse
 */
export class FindPoolContractResponse extends Message<FindPoolContractResponse> {
  /**
   * @generated from field: optional mystiko.config.contract.v1.PoolContractConfig config = 1;
   */
  config?: PoolContractConfig;

  constructor(data?: PartialMessage<FindPoolContractResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'mystiko.api.config.v1.FindPoolContractResponse';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'config', kind: 'message', T: PoolContractConfig, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FindPoolContractResponse {
    return new FindPoolContractResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FindPoolContractResponse {
    return new FindPoolContractResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FindPoolContractResponse {
    return new FindPoolContractResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: FindPoolContractResponse | PlainMessage<FindPoolContractResponse> | undefined,
    b: FindPoolContractResponse | PlainMessage<FindPoolContractResponse> | undefined,
  ): boolean {
    return proto3.util.equals(FindPoolContractResponse, a, b);
  }
}

/**
 * @generated from message mystiko.api.config.v1.FindPoolContractsResponse
 */
export class FindPoolContractsResponse extends Message<FindPoolContractsResponse> {
  /**
   * @generated from field: repeated mystiko.config.contract.v1.PoolContractConfig config = 1;
   */
  config: PoolContractConfig[] = [];

  constructor(data?: PartialMessage<FindPoolContractsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'mystiko.api.config.v1.FindPoolContractsResponse';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'config', kind: 'message', T: PoolContractConfig, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FindPoolContractsResponse {
    return new FindPoolContractsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FindPoolContractsResponse {
    return new FindPoolContractsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FindPoolContractsResponse {
    return new FindPoolContractsResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: FindPoolContractsResponse | PlainMessage<FindPoolContractsResponse> | undefined,
    b: FindPoolContractsResponse | PlainMessage<FindPoolContractsResponse> | undefined,
  ): boolean {
    return proto3.util.equals(FindPoolContractsResponse, a, b);
  }
}

/**
 * @generated from message mystiko.api.config.v1.FindPoolContractByAddressResponse
 */
export class FindPoolContractByAddressResponse extends Message<FindPoolContractByAddressResponse> {
  /**
   * @generated from field: optional mystiko.config.contract.v1.PoolContractConfig config = 1;
   */
  config?: PoolContractConfig;

  constructor(data?: PartialMessage<FindPoolContractByAddressResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'mystiko.api.config.v1.FindPoolContractByAddressResponse';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'config', kind: 'message', T: PoolContractConfig, opt: true },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): FindPoolContractByAddressResponse {
    return new FindPoolContractByAddressResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): FindPoolContractByAddressResponse {
    return new FindPoolContractByAddressResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): FindPoolContractByAddressResponse {
    return new FindPoolContractByAddressResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: FindPoolContractByAddressResponse | PlainMessage<FindPoolContractByAddressResponse> | undefined,
    b: FindPoolContractByAddressResponse | PlainMessage<FindPoolContractByAddressResponse> | undefined,
  ): boolean {
    return proto3.util.equals(FindPoolContractByAddressResponse, a, b);
  }
}

/**
 * @generated from message mystiko.api.config.v1.FindContractByAddressResponse
 */
export class FindContractByAddressResponse extends Message<FindContractByAddressResponse> {
  /**
   * @generated from field: optional mystiko.config.contract.v1.ContractConfig config = 1;
   */
  config?: ContractConfig;

  constructor(data?: PartialMessage<FindContractByAddressResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'mystiko.api.config.v1.FindContractByAddressResponse';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'config', kind: 'message', T: ContractConfig, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FindContractByAddressResponse {
    return new FindContractByAddressResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FindContractByAddressResponse {
    return new FindContractByAddressResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): FindContractByAddressResponse {
    return new FindContractByAddressResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: FindContractByAddressResponse | PlainMessage<FindContractByAddressResponse> | undefined,
    b: FindContractByAddressResponse | PlainMessage<FindContractByAddressResponse> | undefined,
  ): boolean {
    return proto3.util.equals(FindContractByAddressResponse, a, b);
  }
}

/**
 * @generated from message mystiko.api.config.v1.GetTransactionUrlResponse
 */
export class GetTransactionUrlResponse extends Message<GetTransactionUrlResponse> {
  /**
   * @generated from field: optional string url = 1;
   */
  url?: string;

  constructor(data?: PartialMessage<GetTransactionUrlResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'mystiko.api.config.v1.GetTransactionUrlResponse';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'url', kind: 'scalar', T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetTransactionUrlResponse {
    return new GetTransactionUrlResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetTransactionUrlResponse {
    return new GetTransactionUrlResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetTransactionUrlResponse {
    return new GetTransactionUrlResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: GetTransactionUrlResponse | PlainMessage<GetTransactionUrlResponse> | undefined,
    b: GetTransactionUrlResponse | PlainMessage<GetTransactionUrlResponse> | undefined,
  ): boolean {
    return proto3.util.equals(GetTransactionUrlResponse, a, b);
  }
}
