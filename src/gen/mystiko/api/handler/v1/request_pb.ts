// @generated by protoc-gen-es v1.4.2 with parameter "target=ts"
// @generated from file mystiko/api/handler/v1/request.proto (package mystiko.api.handler.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type {
  BinaryReadOptions,
  FieldList,
  JsonReadOptions,
  JsonValue,
  PartialMessage,
  PlainMessage,
} from '@bufbuild/protobuf';
import { Message, proto3 } from '@bufbuild/protobuf';
import { CreateWalletOptions } from '../../../core/handler/v1/wallet_pb.js';
import { CreateAccountOptions, UpdateAccountOptions } from '../../../core/handler/v1/account_pb.js';
import { QueryFilter } from '../../../storage/v1/filter_pb.js';

/**
 * @generated from message mystiko.api.handler.v1.CreateWalletRequest
 */
export class CreateWalletRequest extends Message<CreateWalletRequest> {
  /**
   * @generated from field: mystiko.core.handler.v1.CreateWalletOptions options = 1;
   */
  options?: CreateWalletOptions;

  constructor(data?: PartialMessage<CreateWalletRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'mystiko.api.handler.v1.CreateWalletRequest';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'options', kind: 'message', T: CreateWalletOptions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateWalletRequest {
    return new CreateWalletRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateWalletRequest {
    return new CreateWalletRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateWalletRequest {
    return new CreateWalletRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: CreateWalletRequest | PlainMessage<CreateWalletRequest> | undefined,
    b: CreateWalletRequest | PlainMessage<CreateWalletRequest> | undefined,
  ): boolean {
    return proto3.util.equals(CreateWalletRequest, a, b);
  }
}

/**
 * @generated from message mystiko.api.handler.v1.CheckCurrentRequest
 */
export class CheckCurrentRequest extends Message<CheckCurrentRequest> {
  constructor(data?: PartialMessage<CheckCurrentRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'mystiko.api.handler.v1.CheckCurrentRequest';
  static readonly fields: FieldList = proto3.util.newFieldList(() => []);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckCurrentRequest {
    return new CheckCurrentRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckCurrentRequest {
    return new CheckCurrentRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckCurrentRequest {
    return new CheckCurrentRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: CheckCurrentRequest | PlainMessage<CheckCurrentRequest> | undefined,
    b: CheckCurrentRequest | PlainMessage<CheckCurrentRequest> | undefined,
  ): boolean {
    return proto3.util.equals(CheckCurrentRequest, a, b);
  }
}

/**
 * @generated from message mystiko.api.handler.v1.CheckPasswordRequest
 */
export class CheckPasswordRequest extends Message<CheckPasswordRequest> {
  /**
   * @generated from field: string password = 1;
   */
  password = '';

  constructor(data?: PartialMessage<CheckPasswordRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'mystiko.api.handler.v1.CheckPasswordRequest';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'password', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckPasswordRequest {
    return new CheckPasswordRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckPasswordRequest {
    return new CheckPasswordRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckPasswordRequest {
    return new CheckPasswordRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: CheckPasswordRequest | PlainMessage<CheckPasswordRequest> | undefined,
    b: CheckPasswordRequest | PlainMessage<CheckPasswordRequest> | undefined,
  ): boolean {
    return proto3.util.equals(CheckPasswordRequest, a, b);
  }
}

/**
 * @generated from message mystiko.api.handler.v1.UpdatePasswordRequest
 */
export class UpdatePasswordRequest extends Message<UpdatePasswordRequest> {
  /**
   * @generated from field: string old_password = 1;
   */
  oldPassword = '';

  /**
   * @generated from field: string new_password = 2;
   */
  newPassword = '';

  constructor(data?: PartialMessage<UpdatePasswordRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'mystiko.api.handler.v1.UpdatePasswordRequest';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'old_password', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 2, name: 'new_password', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdatePasswordRequest {
    return new UpdatePasswordRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdatePasswordRequest {
    return new UpdatePasswordRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdatePasswordRequest {
    return new UpdatePasswordRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: UpdatePasswordRequest | PlainMessage<UpdatePasswordRequest> | undefined,
    b: UpdatePasswordRequest | PlainMessage<UpdatePasswordRequest> | undefined,
  ): boolean {
    return proto3.util.equals(UpdatePasswordRequest, a, b);
  }
}

/**
 * @generated from message mystiko.api.handler.v1.ExportMnemonicPhraseRequest
 */
export class ExportMnemonicPhraseRequest extends Message<ExportMnemonicPhraseRequest> {
  /**
   * @generated from field: string password = 1;
   */
  password = '';

  constructor(data?: PartialMessage<ExportMnemonicPhraseRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'mystiko.api.handler.v1.ExportMnemonicPhraseRequest';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'password', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExportMnemonicPhraseRequest {
    return new ExportMnemonicPhraseRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExportMnemonicPhraseRequest {
    return new ExportMnemonicPhraseRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExportMnemonicPhraseRequest {
    return new ExportMnemonicPhraseRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: ExportMnemonicPhraseRequest | PlainMessage<ExportMnemonicPhraseRequest> | undefined,
    b: ExportMnemonicPhraseRequest | PlainMessage<ExportMnemonicPhraseRequest> | undefined,
  ): boolean {
    return proto3.util.equals(ExportMnemonicPhraseRequest, a, b);
  }
}

/**
 * @generated from message mystiko.api.handler.v1.CreateAccountRequest
 */
export class CreateAccountRequest extends Message<CreateAccountRequest> {
  /**
   * @generated from field: mystiko.core.handler.v1.CreateAccountOptions options = 1;
   */
  options?: CreateAccountOptions;

  constructor(data?: PartialMessage<CreateAccountRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'mystiko.api.handler.v1.CreateAccountRequest';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'options', kind: 'message', T: CreateAccountOptions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateAccountRequest {
    return new CreateAccountRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateAccountRequest {
    return new CreateAccountRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateAccountRequest {
    return new CreateAccountRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: CreateAccountRequest | PlainMessage<CreateAccountRequest> | undefined,
    b: CreateAccountRequest | PlainMessage<CreateAccountRequest> | undefined,
  ): boolean {
    return proto3.util.equals(CreateAccountRequest, a, b);
  }
}

/**
 * @generated from message mystiko.api.handler.v1.CountAccountRequest
 */
export class CountAccountRequest extends Message<CountAccountRequest> {
  /**
   * @generated from field: mystiko.storage.v1.QueryFilter filter = 1;
   */
  filter?: QueryFilter;

  constructor(data?: PartialMessage<CountAccountRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'mystiko.api.handler.v1.CountAccountRequest';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'filter', kind: 'message', T: QueryFilter },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CountAccountRequest {
    return new CountAccountRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CountAccountRequest {
    return new CountAccountRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CountAccountRequest {
    return new CountAccountRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: CountAccountRequest | PlainMessage<CountAccountRequest> | undefined,
    b: CountAccountRequest | PlainMessage<CountAccountRequest> | undefined,
  ): boolean {
    return proto3.util.equals(CountAccountRequest, a, b);
  }
}

/**
 * @generated from message mystiko.api.handler.v1.FindAccountRequest
 */
export class FindAccountRequest extends Message<FindAccountRequest> {
  /**
   * @generated from oneof mystiko.api.handler.v1.FindAccountRequest.condition
   */
  condition:
    | {
        /**
         * @generated from field: mystiko.storage.v1.QueryFilter filter = 1;
         */
        value: QueryFilter;
        case: 'filter';
      }
    | {
        /**
         * @generated from field: bool find_all = 2;
         */
        value: boolean;
        case: 'findAll';
      }
    | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<FindAccountRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'mystiko.api.handler.v1.FindAccountRequest';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'filter', kind: 'message', T: QueryFilter, oneof: 'condition' },
    { no: 2, name: 'find_all', kind: 'scalar', T: 8 /* ScalarType.BOOL */, oneof: 'condition' },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FindAccountRequest {
    return new FindAccountRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FindAccountRequest {
    return new FindAccountRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FindAccountRequest {
    return new FindAccountRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: FindAccountRequest | PlainMessage<FindAccountRequest> | undefined,
    b: FindAccountRequest | PlainMessage<FindAccountRequest> | undefined,
  ): boolean {
    return proto3.util.equals(FindAccountRequest, a, b);
  }
}

/**
 * @generated from message mystiko.api.handler.v1.FindAccountByIdentifierRequest
 */
export class FindAccountByIdentifierRequest extends Message<FindAccountByIdentifierRequest> {
  /**
   * @generated from oneof mystiko.api.handler.v1.FindAccountByIdentifierRequest.identifier
   */
  identifier:
    | {
        /**
         * @generated from field: string id = 2;
         */
        value: string;
        case: 'id';
      }
    | {
        /**
         * @generated from field: string shielded_address = 3;
         */
        value: string;
        case: 'shieldedAddress';
      }
    | {
        /**
         * @generated from field: string public_key = 4;
         */
        value: string;
        case: 'publicKey';
      }
    | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<FindAccountByIdentifierRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'mystiko.api.handler.v1.FindAccountByIdentifierRequest';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: 'id', kind: 'scalar', T: 9 /* ScalarType.STRING */, oneof: 'identifier' },
    { no: 3, name: 'shielded_address', kind: 'scalar', T: 9 /* ScalarType.STRING */, oneof: 'identifier' },
    { no: 4, name: 'public_key', kind: 'scalar', T: 9 /* ScalarType.STRING */, oneof: 'identifier' },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FindAccountByIdentifierRequest {
    return new FindAccountByIdentifierRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FindAccountByIdentifierRequest {
    return new FindAccountByIdentifierRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): FindAccountByIdentifierRequest {
    return new FindAccountByIdentifierRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: FindAccountByIdentifierRequest | PlainMessage<FindAccountByIdentifierRequest> | undefined,
    b: FindAccountByIdentifierRequest | PlainMessage<FindAccountByIdentifierRequest> | undefined,
  ): boolean {
    return proto3.util.equals(FindAccountByIdentifierRequest, a, b);
  }
}

/**
 * @generated from message mystiko.api.handler.v1.UpdateAccountRequest
 */
export class UpdateAccountRequest extends Message<UpdateAccountRequest> {
  /**
   * @generated from field: mystiko.core.handler.v1.UpdateAccountOptions options = 1;
   */
  options?: UpdateAccountOptions;

  /**
   * @generated from oneof mystiko.api.handler.v1.UpdateAccountRequest.identifier
   */
  identifier:
    | {
        /**
         * @generated from field: string id = 2;
         */
        value: string;
        case: 'id';
      }
    | {
        /**
         * @generated from field: string shielded_address = 3;
         */
        value: string;
        case: 'shieldedAddress';
      }
    | {
        /**
         * @generated from field: string public_key = 4;
         */
        value: string;
        case: 'publicKey';
      }
    | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<UpdateAccountRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'mystiko.api.handler.v1.UpdateAccountRequest';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'options', kind: 'message', T: UpdateAccountOptions },
    { no: 2, name: 'id', kind: 'scalar', T: 9 /* ScalarType.STRING */, oneof: 'identifier' },
    { no: 3, name: 'shielded_address', kind: 'scalar', T: 9 /* ScalarType.STRING */, oneof: 'identifier' },
    { no: 4, name: 'public_key', kind: 'scalar', T: 9 /* ScalarType.STRING */, oneof: 'identifier' },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateAccountRequest {
    return new UpdateAccountRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateAccountRequest {
    return new UpdateAccountRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateAccountRequest {
    return new UpdateAccountRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: UpdateAccountRequest | PlainMessage<UpdateAccountRequest> | undefined,
    b: UpdateAccountRequest | PlainMessage<UpdateAccountRequest> | undefined,
  ): boolean {
    return proto3.util.equals(UpdateAccountRequest, a, b);
  }
}

/**
 * @generated from message mystiko.api.handler.v1.UpdateEncryptionRequest
 */
export class UpdateEncryptionRequest extends Message<UpdateEncryptionRequest> {
  /**
   * @generated from field: string old_wallet_password = 1;
   */
  oldWalletPassword = '';

  /**
   * @generated from field: string new_wallet_password = 2;
   */
  newWalletPassword = '';

  constructor(data?: PartialMessage<UpdateEncryptionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'mystiko.api.handler.v1.UpdateEncryptionRequest';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'old_wallet_password', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 2, name: 'new_wallet_password', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateEncryptionRequest {
    return new UpdateEncryptionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateEncryptionRequest {
    return new UpdateEncryptionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateEncryptionRequest {
    return new UpdateEncryptionRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: UpdateEncryptionRequest | PlainMessage<UpdateEncryptionRequest> | undefined,
    b: UpdateEncryptionRequest | PlainMessage<UpdateEncryptionRequest> | undefined,
  ): boolean {
    return proto3.util.equals(UpdateEncryptionRequest, a, b);
  }
}

/**
 * @generated from message mystiko.api.handler.v1.ExportSecretKeyRequest
 */
export class ExportSecretKeyRequest extends Message<ExportSecretKeyRequest> {
  /**
   * @generated from field: string wallet_password = 1;
   */
  walletPassword = '';

  /**
   * @generated from oneof mystiko.api.handler.v1.ExportSecretKeyRequest.identifier
   */
  identifier:
    | {
        /**
         * @generated from field: string id = 2;
         */
        value: string;
        case: 'id';
      }
    | {
        /**
         * @generated from field: string public_key = 3;
         */
        value: string;
        case: 'publicKey';
      }
    | {
        /**
         * @generated from field: string shielded_address = 4;
         */
        value: string;
        case: 'shieldedAddress';
      }
    | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ExportSecretKeyRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'mystiko.api.handler.v1.ExportSecretKeyRequest';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'wallet_password', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 2, name: 'id', kind: 'scalar', T: 9 /* ScalarType.STRING */, oneof: 'identifier' },
    { no: 3, name: 'public_key', kind: 'scalar', T: 9 /* ScalarType.STRING */, oneof: 'identifier' },
    { no: 4, name: 'shielded_address', kind: 'scalar', T: 9 /* ScalarType.STRING */, oneof: 'identifier' },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExportSecretKeyRequest {
    return new ExportSecretKeyRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExportSecretKeyRequest {
    return new ExportSecretKeyRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExportSecretKeyRequest {
    return new ExportSecretKeyRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: ExportSecretKeyRequest | PlainMessage<ExportSecretKeyRequest> | undefined,
    b: ExportSecretKeyRequest | PlainMessage<ExportSecretKeyRequest> | undefined,
  ): boolean {
    return proto3.util.equals(ExportSecretKeyRequest, a, b);
  }
}
